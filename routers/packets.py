# routers/packets.py - Complete implementation with database

import hashlib
import re
from datetime import datetime
from pathlib import Path as PathLib
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Path, Query, Request
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session

from app.database import Client, League, Packet, get_db
from app.logging_config import get_logger
from app.services.league_utils import parse_league_id
from app.services.packet_service import PacketService, parse_packet_filename
from routers.auth import get_current_client

logger = get_logger(context="api")

router = APIRouter()


@router.put("/leagues/{league_id}/packets/{filename}", summary="Upload Packet")
async def upload_packet(
    league_id: str = Path(..., pattern=r'^\d{3}[BF]$'),
    filename: str = Path(...),
    request: Request = None,
    client: Client = Depends(get_current_client),
    db: Session = Depends(get_db),
):
    """
    Upload a game packet to the hub using PUT with raw body

    **Path Parameters:**
    - `league_id`: League identifier with game type (e.g., "555B" for BRE, "555F" for FE)
    - `filename`: Packet filename (e.g., "555B0201.001")

    **Request Body:** Raw file data (application/octet-stream)

    **Packet Filename Format:** `<league><game><source><dest>.<seq>`
    - League: 3 digits (e.g., 555)
    - Game: B (BRE) or F (FE)
    - Source: 2-digit hex BBS index (e.g., 02)
    - Dest: 2-digit hex BBS index (e.g., 01)
    - Seq: 3-digit sequence (000-999)

    **Example:** `555B0201.001` = BRE League 555, from BBS 02 to BBS 01, seq 1

    **Authentication:** Requires Bearer token

    **Example:**
    ```bash
    curl -X PUT "https://hub.example.com/api/v1/leagues/555B/packets/555B0201.001" \\
      -H "Authorization: Bearer YOUR_TOKEN" \\
      -H "Content-Type: application/octet-stream" \\
      --data-binary "@555B0201.001"
    ```
    """

    # Parse league_id from URL (e.g., "555B" -> ("555", "B"))
    league_number, league_game_type = parse_league_id(league_id)

    # Normalize filename to uppercase (server-side normalization)
    normalized_filename = filename.upper()

    # Block nodelist uploads from clients
    # Nodelists are only generated by the hub's game instance
    if normalized_filename.startswith("BRNODES.") or normalized_filename.startswith("FENODES."):
        raise HTTPException(
            status_code=403,
            detail="Nodelist files cannot be uploaded by clients - they are hub-generated only"
        )

    # Parse and validate filename
    try:
        packet_info = parse_packet_filename(normalized_filename)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

    # Verify league_id matches filename (BOTH number AND game type)
    if packet_info["league_id"] != league_number:
        raise HTTPException(
            status_code=400,
            detail=f"League number mismatch: filename={packet_info['league_id']}, URL={league_number}",
        )

    if packet_info["game_type"] != league_game_type:
        raise HTTPException(
            status_code=400,
            detail=f"Game type mismatch: filename={packet_info['game_type']}, URL={league_game_type}",
        )

    # Read raw request body
    content = await request.body()
    if not content:
        raise HTTPException(status_code=400, detail="Empty request body")

    # Query league by BOTH league_id AND game_type
    league = (
        db.query(League)
        .filter(
            League.league_id == league_number,
            League.game_type == league_game_type,
        )
        .first()
    )

    if not league:
        # Determine full game type name for display
        game_full = "BRE" if league_game_type == "B" else "FE"
        league = League(
            league_id=league_number,
            game_type=league_game_type,
            name=f"{game_full} League {league_number}",
            is_active=True,
        )
        db.add(league)
        db.commit()
        db.refresh(league)

    # Check client membership in this league
    from app.database import LeagueMembership

    membership = (
        db.query(LeagueMembership)
        .filter(
            LeagueMembership.client_id == client.id,
            LeagueMembership.league_id == league.id,
            LeagueMembership.is_active == True,
        )
        .first()
    )

    if not membership:
        raise HTTPException(
            status_code=403,
            detail=f"Client {client.client_id} is not a member of league {league_id}",
        )

    # Convert membership BBS index to hex for comparison
    membership_bbs_hex = format(membership.bbs_index, "02X")

    # Verify client is authorized for this source BBS
    if packet_info["source_bbs_index"].upper() != membership_bbs_hex:
        raise HTTPException(
            status_code=403,
            detail=f"Client {client.client_id} BBS ID {membership.bbs_index} (0x{membership_bbs_hex}) cannot upload packets from BBS {packet_info['source_bbs_index']}",
        )

    # Calculate file hash
    file_hash = hashlib.sha256(content).hexdigest()

    # Note: Duplicate filenames ARE allowed to support:
    # 1. Game resets (sequence numbers restart at 001)
    # 2. Sequence wraparound (999 -> 000/001)
    # BRE/FE games have built-in duplicate detection to prevent cheating

    # Save file to inbound directory
    data_dir = request.app.state.config.get("server", {}).get("data_dir", "./data")
    inbound_dir = PathLib(data_dir) / "packets" / "inbound"
    inbound_dir.mkdir(parents=True, exist_ok=True)

    filepath = inbound_dir / normalized_filename
    filepath.write_bytes(content)

    # Create packet record
    packet = Packet(
        filename=normalized_filename,
        league_id=league.id,
        source_bbs_index=packet_info["source_bbs_index"],
        dest_bbs_index=packet_info["dest_bbs_index"],
        sequence_number=packet_info["sequence_number"],
        file_size=len(content),
        file_data=content,
        checksum=file_hash,
    )
    db.add(packet)
    db.commit()

    # Trigger processing (fire and forget)
    from app.services.processing_service import trigger_processing

    trigger_processing()

    return {"status": "received", "filename": normalized_filename, "packet_id": packet.id}


@router.get("/leagues/{league_id}/packets", summary="List Available Packets")
async def list_packets(
    league_id: str = Path(..., pattern=r'^\d{3}[BF]$'),
    unread: bool = Query(False, description="Filter to only unread (not downloaded) packets"),
    client: Client = Depends(get_current_client),
    db: Session = Depends(get_db),
):
    """
    List packets available for download by this client

    **Path Parameters:**
    - `league_id`: League identifier with game type (e.g., "555B" for BRE, "555F" for FE)

    **Query Parameters:**
    - `unread`: Set to `true` to only show packets not yet downloaded (default: false)

    **Returns:** List of packets destined for this client's BBS

    **Authentication:** Requires Bearer token

    **Example:**
    ```bash
    # Get all packets
    curl -X GET "https://hub.example.com/api/v1/leagues/555B/packets" \\
      -H "Authorization: Bearer YOUR_TOKEN"

    # Get only unread packets
    curl -X GET "https://hub.example.com/api/v1/leagues/555B/packets?unread=true" \\
      -H "Authorization: Bearer YOUR_TOKEN"
    ```
    """

    # Parse league_id from URL (e.g., "555B" -> ("555", "B"))
    league_number, league_game_type = parse_league_id(league_id)

    # Get league by BOTH league_id AND game_type
    league = (
        db.query(League)
        .filter(
            League.league_id == league_number,
            League.game_type == league_game_type
        )
        .first()
    )

    if not league:
        return {"packets": []}

    league_ids = [league.id]

    # Get client memberships for these leagues to determine BBS indexes
    from app.database import LeagueMembership

    memberships = (
        db.query(LeagueMembership)
        .filter(
            LeagueMembership.client_id == client.id,
            LeagueMembership.league_id.in_(league_ids),
            LeagueMembership.is_active == True,
        )
        .all()
    )

    if not memberships:
        return {"packets": []}

    # Build list of (league_id, bbs_hex) tuples for filtering
    bbs_filters = [(m.league_id, format(m.bbs_index, "02X")) for m in memberships]

    # Query packets for any matching (league_id, dest_bbs) combination
    from sqlalchemy import and_, or_

    filters = [
        and_(Packet.league_id == lid, Packet.dest_bbs_index == bbs_hex)
        for lid, bbs_hex in bbs_filters
    ]

    query = db.query(Packet).filter(or_(*filters))

    if unread:
        query = query.filter(Packet.downloaded_at == None)

    packets = query.order_by(Packet.uploaded_at.desc()).all()

    packet_list = []
    for packet in packets:
        league = db.query(League).filter(League.id == packet.league_id).first()
        packet_list.append(
            {
                "filename": packet.filename,
                "league": league.league_id,
                "game_type": league.game_type,
                "source": packet.source_bbs_index,
                "dest": packet.dest_bbs_index,
                "sequence": packet.sequence_number,
                "received_at": packet.uploaded_at.isoformat(),
                "retrieved_at": packet.downloaded_at.isoformat()
                if packet.downloaded_at
                else None,
                "file_size": packet.file_size,
            }
        )

    return {"packets": packet_list}


@router.get("/leagues/{league_id}/nodelist", summary="Download Nodelist")
async def download_nodelist(
    league_id: str = Path(..., pattern=r'^\d{3}[BF]$'),
    request: Request = None,
    client: Client = Depends(get_current_client),
    db: Session = Depends(get_db),
):
    """
    Download the latest nodelist file for a league

    **Path Parameters:**
    - `league_id`: League identifier with game type (e.g., "555B" for BRE, "555F" for FE)

    **Returns:** Binary nodelist file (BRNODES.xxx or FENODES.xxx)

    **Description:**
    The nodelist contains information about all BBS nodes in the league.
    These files are generated by the hub and should be placed in your game directory.

    **Authentication:** Requires Bearer token and league membership

    **Example:**
    ```bash
    curl -X GET "https://hub.example.com/api/v1/leagues/555B/nodelist" \\
      -H "Authorization: Bearer YOUR_TOKEN" \\
      -o BRNODES.555
    ```
    """
    # Parse league_id from URL (e.g., "555B" -> ("555", "B"))
    league_number, league_game_type = parse_league_id(league_id)

    # Get client membership for this league to determine game type
    from app.database import LeagueMembership

    # Get league by BOTH league_id AND game_type
    league = (
        db.query(League)
        .filter(
            League.league_id == league_number,
            League.game_type == league_game_type
        )
        .first()
    )

    if not league:
        raise HTTPException(status_code=404, detail=f"League {league_id} not found")

    # Check if client is a member of this specific league
    membership = (
        db.query(LeagueMembership)
        .filter(
            LeagueMembership.client_id == client.id,
            LeagueMembership.league_id == league.id,
            LeagueMembership.is_active == True,
        )
        .first()
    )

    if not membership:
        raise HTTPException(
            status_code=403,
            detail=f"Client {client.client_id} is not a member of league {league_id}",
        )

    # Determine game type
    game_type = "BRE" if league.game_type == "B" else "FE"

    # Construct nodelist filename
    nodelist_filename = f"{'BR' if game_type == 'BRE' else 'FE'}NODES.{league_number}"

    # Find nodelist file in nodelists directory
    data_dir = request.app.state.config.get("server", {}).get("data_dir", "./data")
    nodelists_dir = PathLib(data_dir) / "nodelists" / game_type.lower() / league_number

    # Case-insensitive file search
    from app.services.processing_service import find_file_case_insensitive

    nodelist_path = find_file_case_insensitive(nodelists_dir, nodelist_filename)

    if not nodelist_path or not nodelist_path.exists():
        raise HTTPException(
            status_code=404,
            detail=f"Nodelist not available for league {league_id}",
        )

    logger.info(f"Client {client.client_id} downloading nodelist: {nodelist_path.name}")

    # Mark the nodelist packet as downloaded
    dest_bbs_hex = f"{membership.bbs_index:02X}"
    nodelist_packet = (
        db.query(Packet)
        .filter(
            Packet.filename == nodelist_path.name,
            Packet.league_id == league.id,
            Packet.dest_bbs_index == dest_bbs_hex,
        )
        .first()
    )

    if nodelist_packet:
        nodelist_packet.downloaded_at = datetime.now()
        nodelist_packet.is_downloaded = True
        db.commit()
        logger.debug(f"Marked nodelist packet {nodelist_path.name} as downloaded for BBS {dest_bbs_hex}")

    return FileResponse(
        nodelist_path,
        filename=nodelist_path.name,
        media_type="application/octet-stream",
    )


@router.get("/leagues/{league_id}/packets/{filename}", summary="Download Packet")
async def download_packet(
    league_id: str = Path(..., pattern=r'^\d{3}[BF]$'),
    filename: str = Path(...),
    request: Request = None,
    client: Client = Depends(get_current_client),
    db: Session = Depends(get_db),
):
    """
    Download a specific packet file

    **Path Parameters:**
    - `league_id`: League identifier with game type (e.g., "555B" for BRE, "555F" for FE)
    - `filename`: Packet filename (e.g., "555B0102.001")

    **Returns:** Binary packet file

    **Description:**
    Downloads a packet that is destined for your BBS. The packet is automatically
    marked as downloaded after successful retrieval.

    **Authentication:** Requires Bearer token and authorization for destination BBS

    **Example:**
    ```bash
    curl -X GET "https://hub.example.com/api/v1/leagues/555B/packets/555B0102.001" \\
      -H "Authorization: Bearer YOUR_TOKEN" \\
      -o 555B0102.001
    ```
    """

    # Parse league_id from URL (e.g., "555B" -> ("555", "B"))
    league_number, league_game_type = parse_league_id(league_id)

    # Normalize filename to uppercase for consistent lookup
    normalized_filename = filename.upper()

    # Check if this is a nodelist file
    is_nodelist = normalized_filename.startswith("BRNODES.") or normalized_filename.startswith("FENODES.")

    if is_nodelist:
        # Handle nodelist download
        # Get league
        league = (
            db.query(League)
            .filter(
                League.league_id == league_number,
                League.game_type == league_game_type
            )
            .first()
        )

        if not league:
            raise HTTPException(status_code=404, detail=f"League {league_id} not found")

        # Get client membership
        from app.database import LeagueMembership

        membership = (
            db.query(LeagueMembership)
            .filter(
                LeagueMembership.client_id == client.id,
                LeagueMembership.league_id == league.id,
                LeagueMembership.is_active == True,
            )
            .first()
        )

        if not membership:
            raise HTTPException(
                status_code=403,
                detail=f"Client {client.client_id} is not a member of league {league_id}",
            )

        # Find the nodelist file
        data_dir = request.app.state.config.get("server", {}).get("data_dir", "./data")
        game_type_str = "BRE" if league_game_type == "B" else "FE"
        nodelists_dir = PathLib(data_dir) / "nodelists" / game_type_str.lower() / league_number

        from app.services.processing_service import find_file_case_insensitive
        nodelist_path = find_file_case_insensitive(nodelists_dir, normalized_filename)

        if not nodelist_path or not nodelist_path.exists():
            raise HTTPException(
                status_code=404,
                detail=f"Nodelist file not found",
            )

        # Mark the nodelist packet as downloaded
        dest_bbs_hex = f"{membership.bbs_index:02X}"
        nodelist_packet = (
            db.query(Packet)
            .filter(
                Packet.filename == normalized_filename,
                Packet.league_id == league.id,
                Packet.dest_bbs_index == dest_bbs_hex,
            )
            .first()
        )

        if nodelist_packet:
            nodelist_packet.downloaded_at = datetime.now()
            nodelist_packet.is_downloaded = True
            db.commit()
            logger.debug(f"Marked nodelist packet {normalized_filename} as downloaded for BBS {dest_bbs_hex}")

        logger.info(f"Client {client.client_id} downloading nodelist: {nodelist_path.name}")

        return FileResponse(
            nodelist_path,
            filename=nodelist_path.name,
            media_type="application/octet-stream",
        )

    else:
        # Handle regular packet download
        # Parse filename to verify destination
        try:
            packet_info = parse_packet_filename(normalized_filename)
        except ValueError as e:
            raise HTTPException(status_code=400, detail=str(e))

        # Verify league_id matches filename (BOTH number AND game type)
        if packet_info["league_id"] != league_number:
            raise HTTPException(
                status_code=400,
                detail=f"League number mismatch: filename={packet_info['league_id']}, URL={league_number}",
            )

        if packet_info["game_type"] != league_game_type:
            raise HTTPException(
                status_code=400,
                detail=f"Game type mismatch: filename={packet_info['game_type']}, URL={league_game_type}",
            )

        # Get packet record - prioritize undownloaded packets and newest first
        # This handles cases where the same filename exists multiple times
        packet = (
            db.query(Packet)
            .filter(Packet.filename == normalized_filename)
            .order_by(Packet.is_downloaded.asc(), Packet.uploaded_at.desc())
            .first()
        )
        if not packet:
            logger.warning(f"Packet {normalized_filename} not found in database")
            raise HTTPException(status_code=404, detail="Packet not found")

        # Get client membership for this league
        from app.database import LeagueMembership

        membership = (
            db.query(LeagueMembership)
            .filter(
                LeagueMembership.client_id == client.id,
                LeagueMembership.league_id == packet.league_id,
                LeagueMembership.is_active == True,
            )
            .first()
        )

        if not membership:
            raise HTTPException(
                status_code=403,
                detail="Client is not a member of this league",
            )

        # Verify client's BBS index matches packet destination
        membership_bbs_hex = format(membership.bbs_index, "02X")
        if packet_info["dest_bbs_index"].upper() != membership_bbs_hex:
            raise HTTPException(
                status_code=403,
                detail=f"Cannot download packets for BBS {packet_info['dest_bbs_index']} (client BBS ID is {membership.bbs_index}/0x{membership_bbs_hex})",
            )

        # Check file exists (use normalized filename)
        data_dir = request.app.state.config.get("server", {}).get("data_dir", "./data")
        filepath = PathLib(data_dir) / "packets" / "outbound" / normalized_filename
        logger.debug(f"Looking for packet at: {filepath}")
        if not filepath.exists():
            raise HTTPException(status_code=404, detail="Packet file not found")

        # Mark as retrieved
        packet.downloaded_at = datetime.now()
        packet.is_downloaded = True
        db.commit()

        return FileResponse(
            filepath, filename=normalized_filename, media_type="application/octet-stream"
        )
