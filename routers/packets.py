# routers/packets.py - Complete implementation with database

import hashlib
import re
from datetime import datetime
from pathlib import Path
from typing import Optional

from fastapi import APIRouter, Depends, File, HTTPException, Query, Request, UploadFile
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session

from app.database import Client, League, Packet, get_db
from app.services.packet_service import PacketService, parse_packet_filename
from routers.auth import get_current_client

router = APIRouter()


@router.post("/leagues/{league_id}/packets")
async def upload_packet(
    league_id: str,
    request: Request,
    file: UploadFile = File(...),
    client: Client = Depends(get_current_client),
    db: Session = Depends(get_db),
):
    """Upload a packet to the hub"""

    # Block nodelist uploads from clients
    # Nodelists are only generated by the hub's game instance
    filename_upper = file.filename.upper()
    if filename_upper.startswith("BRNODES.") or filename_upper.startswith("FENODES."):
        raise HTTPException(
            status_code=403,
            detail="Nodelist files cannot be uploaded by clients - they are hub-generated only"
        )

    # Parse and validate filename
    try:
        packet_info = parse_packet_filename(file.filename)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

    # Verify league matches
    if packet_info["league_id"] != league_id:
        raise HTTPException(
            status_code=400,
            detail=f"League mismatch: filename says {packet_info['league_id']}, URL says {league_id}",
        )

    # Ensure league exists (game_type in DB is single letter: B or F)
    league = (
        db.query(League)
        .filter(
            League.league_id == packet_info["league_id"],
            League.game_type == packet_info["game_type"],
        )
        .first()
    )

    if not league:
        # Determine full game type name for display
        game_full = "BRE" if packet_info["game_type"] == "B" else "FE"
        league = League(
            league_id=packet_info["league_id"],
            game_type=packet_info["game_type"],
            name=f"{game_full} League {packet_info['league_id']}",
            is_active=True,
        )
        db.add(league)
        db.commit()
        db.refresh(league)

    # Check client membership in this league
    from app.database import LeagueMembership

    membership = (
        db.query(LeagueMembership)
        .filter(
            LeagueMembership.client_id == client.id,
            LeagueMembership.league_id == league.id,
            LeagueMembership.is_active == True,
        )
        .first()
    )

    if not membership:
        raise HTTPException(
            status_code=403,
            detail=f"Client {client.client_id} is not a member of league {league_id}",
        )

    # Convert membership BBS index to hex for comparison
    membership_bbs_hex = format(membership.bbs_index, "02X")

    # Verify client is authorized for this source BBS
    if packet_info["source_bbs_index"].upper() != membership_bbs_hex:
        raise HTTPException(
            status_code=403,
            detail=f"Client {client.client_id} BBS ID {membership.bbs_index} (0x{membership_bbs_hex}) cannot upload packets from BBS {packet_info['source_bbs_index']}",
        )

    # Read file content
    content = await file.read()
    file_hash = hashlib.sha256(content).hexdigest()

    # Normalize filename to uppercase (DOS convention)
    # This ensures consistent case in database and filesystem
    normalized_filename = file.filename.upper()

    # Note: Duplicate filenames ARE allowed to support:
    # 1. Game resets (sequence numbers restart at 001)
    # 2. Sequence wraparound (999 -> 000/001)
    # BRE/FE games have built-in duplicate detection to prevent cheating

    # Save file to inbound directory
    data_dir = request.app.state.config.get("server", {}).get("data_dir", "./data")
    inbound_dir = Path(data_dir) / "packets" / "inbound"
    inbound_dir.mkdir(parents=True, exist_ok=True)

    filepath = inbound_dir / normalized_filename
    filepath.write_bytes(content)

    # Create packet record
    packet = Packet(
        filename=normalized_filename,
        league_id=league.id,
        source_bbs_index=packet_info["source_bbs_index"],
        dest_bbs_index=packet_info["dest_bbs_index"],
        sequence_number=packet_info["sequence_number"],
        file_size=len(content),
        file_data=content,
        checksum=file_hash,
    )
    db.add(packet)
    db.commit()

    # Trigger processing (fire and forget)
    from app.services.processing_service import trigger_processing

    trigger_processing()

    return {"status": "received", "filename": normalized_filename, "packet_id": packet.id}


@router.get("/leagues/{league_id}/packets")
async def list_packets(
    league_id: str,
    unread: bool = Query(False),
    client: Client = Depends(get_current_client),
    db: Session = Depends(get_db),
):
    """List packets available for this client"""

    # Get league
    leagues = db.query(League).filter(League.league_id == league_id).all()
    if not leagues:
        return {"packets": []}

    league_ids = [l.id for l in leagues]

    # Get client memberships for these leagues to determine BBS indexes
    from app.database import LeagueMembership

    memberships = (
        db.query(LeagueMembership)
        .filter(
            LeagueMembership.client_id == client.id,
            LeagueMembership.league_id.in_(league_ids),
            LeagueMembership.is_active == True,
        )
        .all()
    )

    if not memberships:
        return {"packets": []}

    # Build list of (league_id, bbs_hex) tuples for filtering
    bbs_filters = [(m.league_id, format(m.bbs_index, "02X")) for m in memberships]

    # Query packets for any matching (league_id, dest_bbs) combination
    from sqlalchemy import and_, or_

    filters = [
        and_(Packet.league_id == lid, Packet.dest_bbs_index == bbs_hex)
        for lid, bbs_hex in bbs_filters
    ]

    query = db.query(Packet).filter(or_(*filters))

    if unread:
        query = query.filter(Packet.downloaded_at == None)

    packets = query.order_by(Packet.uploaded_at.desc()).all()

    packet_list = []
    for packet in packets:
        league = db.query(League).filter(League.id == packet.league_id).first()
        packet_list.append(
            {
                "filename": packet.filename,
                "league": league.league_id,
                "game_type": league.game_type,
                "source": packet.source_bbs_index,
                "dest": packet.dest_bbs_index,
                "sequence": packet.sequence_number,
                "received_at": packet.uploaded_at.isoformat(),
                "retrieved_at": packet.downloaded_at.isoformat()
                if packet.downloaded_at
                else None,
                "file_size": packet.file_size,
            }
        )

    return {"packets": packet_list}


@router.get("/leagues/{league_id}/nodelist")
async def download_nodelist(
    league_id: str,
    request: Request,
    client: Client = Depends(get_current_client),
    db: Session = Depends(get_db),
):
    """
    Download the latest nodelist file for a league.
    Returns BRNODES.<league> or FENODES.<league> file.
    All clients in the league can download this file.
    """
    # Get client membership for this league to determine game type
    from app.database import LeagueMembership

    # Get all leagues with this league_id
    leagues = db.query(League).filter(League.league_id == league_id).all()
    if not leagues:
        raise HTTPException(status_code=404, detail="League not found")

    # Check if client is a member of any league with this ID
    league_ids = [l.id for l in leagues]
    membership = (
        db.query(LeagueMembership)
        .filter(
            LeagueMembership.client_id == client.id,
            LeagueMembership.league_id.in_(league_ids),
            LeagueMembership.is_active == True,
        )
        .first()
    )

    if not membership:
        raise HTTPException(
            status_code=403,
            detail=f"Client {client.client_id} is not a member of league {league_id}",
        )

    # Get the league to determine game type
    league = db.query(League).filter(League.id == membership.league_id).first()
    game_type = "BRE" if league.game_type == "B" else "FE"

    # Construct nodelist filename
    nodelist_filename = f"{'BR' if game_type == 'BRE' else 'FE'}NODES.{league_id}"

    # Find nodelist file in nodelists directory
    data_dir = request.app.state.config.get("server", {}).get("data_dir", "./data")
    nodelists_dir = Path(data_dir) / "nodelists" / game_type.lower() / league_id

    # Case-insensitive file search
    from app.services.processing_service import find_file_case_insensitive

    nodelist_path = find_file_case_insensitive(nodelists_dir, nodelist_filename)

    if not nodelist_path or not nodelist_path.exists():
        raise HTTPException(
            status_code=404,
            detail=f"Nodelist not available for league {league_id}",
        )

    print(f"[API] Client {client.client_id} downloading nodelist: {nodelist_path.name}")

    return FileResponse(
        nodelist_path,
        filename=nodelist_path.name,
        media_type="application/octet-stream",
    )


@router.get("/leagues/{league_id}/packets/{filename}")
async def download_packet(
    league_id: str,
    filename: str,
    request: Request,
    client: Client = Depends(get_current_client),
    db: Session = Depends(get_db),
):
    """Download a specific packet"""

    # Normalize filename to uppercase for consistent lookup
    normalized_filename = filename.upper()

    # Parse filename to verify destination
    try:
        packet_info = parse_packet_filename(normalized_filename)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

    # Get packet record first to determine league
    packet = db.query(Packet).filter(Packet.filename == normalized_filename).first()
    if not packet:
        print(f"Packet {normalized_filename} not found in database")
        raise HTTPException(status_code=404, detail="Packet not found")

    # Get client membership for this league
    from app.database import LeagueMembership

    membership = (
        db.query(LeagueMembership)
        .filter(
            LeagueMembership.client_id == client.id,
            LeagueMembership.league_id == packet.league_id,
            LeagueMembership.is_active == True,
        )
        .first()
    )

    if not membership:
        raise HTTPException(
            status_code=403,
            detail="Client is not a member of this league",
        )

    # Verify client's BBS index matches packet destination
    membership_bbs_hex = format(membership.bbs_index, "02X")
    if packet_info["dest_bbs_index"].upper() != membership_bbs_hex:
        raise HTTPException(
            status_code=403,
            detail=f"Cannot download packets for BBS {packet_info['dest_bbs_index']} (client BBS ID is {membership.bbs_index}/0x{membership_bbs_hex})",
        )

    # Check file exists (use normalized filename)
    data_dir = request.app.state.config.get("server", {}).get("data_dir", "./data")
    filepath = Path(data_dir) / "packets" / "outbound" / normalized_filename
    print(f"Looking for packet at: {filepath}")
    if not filepath.exists():
        raise HTTPException(status_code=404, detail="Packet file not found")

    # Mark as retrieved
    packet.downloaded_at = datetime.now()
    db.commit()

    return FileResponse(
        filepath, filename=normalized_filename, media_type="application/octet-stream"
    )
